#!/usr/bin/python

import tempfile
import subprocess
import shlex
import shutil
import zipfile
import argparse
import pefile
import requests

from cStringIO import StringIO

import logging
logging.basicConfig(level=logging.DEBUG,format="[%(asctime)s] [%(module)s] [%(levelname)s] %(message)s")
log = logging.getLogger()

def _get_vad(cuckoo_api_url,task,pid,base):
    vad = None
    r = requests.post("{}tasks/volatility/{}/vaddump".format(cuckoo_api_url,task),data={'pid':pid,'BASE':base})
    if r.status_code == 200:
        z = zipfile.ZipFile(StringIO(r.content))
        for f in z.namelist():
            print f
            if f.endswith('.dmp'):
                vad = z.read(f)
                break
    return vad

def _get_malfinds(cuckoo_api_url,task,pid):
    malfind_pages = set()
    r = requests.post("{}tasks/volatility/{}/malfindtxt".format(cuckoo_api_url,task),data={'pid':pid})
    if r.status_code == 200:
        for line in r.json()['response'].split('\n'):
            if line.startswith('Process:'):
                addr = line.strip().split(' ')[-1]
                log.debug("[+] Malfind page: {:s}".format(addr))
                malfind_pages.add(int(addr,16) & 0xffff0000)
    return malfind_pages

def _parse_behavior_json(cuckoo_api_url,task,pid):
    page_addresses = set()
    addresses = []
    proc_name = "unk"
    r = requests.get("{}tasks/report/{}/json".format(cuckoo_api_url,task))
    if r.status_code == 200:
        for process in r.json().get('behavior',{}).get('processes',{}):
            if 'pid' in process and process['pid'] == pid:
                proc_name = process['process_name']
                for call in process['calls']:
                    if call['api'] == 'InternetConnectA': print call
                    if call['stacktrace']:
                        for stack in call['stacktrace']:
                            if '@' in stack:
                                call_addr = stack.split('@')[1].strip()
                                proc = stack.split('+')[0]
                                if proc_name.startswith(proc):
                                    addresses.append(call_addr)
                            else:
                                addresses.append(stack)
                break
            if 'process_id' in process and process['process_id'] == pid:
                proc_name = process['process_name']
                for call in process['calls']:
                    if 'caller' not in call: continue
                    if int(call['caller'],16):
                        addresses.append(call['caller'])
                    if int(call['parentcaller'],16):
                        addresses.append(call['parentcaller'])
                break
    for addr in addresses:
        page_addresses.add(int(addr,16)&0xffff0000)
    return proc_name,sorted(list(page_addresses))

def _parse_vadwalk(task,pid):
    r = requests.post("{}tasks/volatility/{}/vadwalk".format(cuckoo_api_url,task),data={'pid':pid})
    vads = []
    if r.status_code == 200:
       for vad in r.json()["response"].strip().split("\n")[4:-1]:
            vads.append([int(x,16) for x in vad.strip().split(" ")[-3:-1]])
    return vads

def _get_dump(task_id,pid):
    r = requests.post("{}tasks/volatility/{}/procdump".format(cuckoo_api_url,task_id),data={'pid':pid,'memory':True,'unsafe':True})
    z = zipfile.ZipFile(StringIO(r.content))
    dump = z.read('executable.{}.exe'.format(pid))
    return dump

def _rebase_pe(pe,new_image_base):
    old_image_base = pe.OPTIONAL_HEADER.ImageBase
    rebase_offset = old_image_base - new_image_base
    for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
        d.VirtualAddress = d.VirtualAddress + rebase_offset
    for s in pe.sections:
        s.VirtualAddress = s.VirtualAddress + rebase_offset
    pe.OPTIONAL_HEADER.ImageBase = new_image_base
    return pe

def main():
    parser = argparse.ArgumentParser(description="Create unified dump from Cuckoo Trace info")
    parser.add_argument("--task",type=int,required=True,help="Task to operate on")
    parser.add_argument("--pid",type=int,required=True,help="PID to operate on")
    parser.add_argument("--ida-path",dest="ida_path",required=True,help="Path to idal binary for automated IDB creation")
    parser.add_argument("--cuckoo-host",dest="cuckoo_host",required=True,help="Cuckoo Host to connect to")
    parser.add_argument("--cuckoo-port",type=int,dest="cuckoo_port",required=True,help="Cuckoo Port to connect to")
    cuckoo_api_url = "http://{}:{:d}/".format(args.cuckoo_host,args.cuckoo_port)
    args = parser.parse_args()
    tmpdir = tempfile.mkdtemp()
    log.debug("[+] Using tmpdir {}".format(tmpdir))
    proc_name, executed_pages = _parse_behavior_json(cuckoo_api_url,args.task,args.pid)
    dump = _get_dump(args.task,args.pid)
    proc_dmp_file = '{}/{}-{}.ex_'.format(tmpdir,proc_name,args.pid)
    idb_path = '{}-{}.idb'.format(proc_name,args.pid)
    with open(proc_dmp_file,'wb') as f:
        f.write(dump)
    pe = pefile.PE(data=dump)
    min_addr = pe.OPTIONAL_HEADER.ImageBase
    max_addr = len(pe.get_memory_mapped_image()) + min_addr
    log.debug("[+] Base memory range: {:08X} -> {:08X}".format(min_addr,max_addr))
    interesting_pages = []
    for page in executed_pages:
        if page > max_addr or page < min_addr:
            log.debug("[+] Interesting page: 0x{:08X}".format(page))
            interesting_pages.append(page)
    interesting_pages += list(_get_malfinds(cuckoo_api_url,args.task,args.pid))
    vads_to_get = set()
    if interesting_pages:
        vads = _parse_vadwalk(cuckoo_api_url,args.task,args.pid)
        if args.force_below:
            for vad in vads:
                if vad[1] < min_addr:
                    log.debug("[+] Interesting page below ImageBase 0x{:08X} is in VAD 0x{:08X} - 0x{:08X}".format(vad[0],vad[0],vad[1]))
                    interesting_pages.append(page)
        for page in interesting_pages:
            prev_vad = None
            get_next = False
            for vad in vads:
                if vad[0] <= page and page < vad[1]:
                    log.debug("[+] Interesting page 0x{:08X} is in VAD 0x{:08X} - 0x{:08X}".format(page,vad[0],vad[1]))
                    vads_to_get.add(vad[0])
                    if prev_vad:
                        vads_to_get.add(prev_vad[0])
                        log.debug("[+] Interesting page below 0x{:08X} is in VAD 0x{:08X} - 0x{:08X}".format(page,prev_vad[0],prev_vad[1]))
                    get_next = True
                elif get_next:
                    log.debug("[+] Interesting page above 0x{:08X} is in VAD 0x{:08X} - 0x{:08X}".format(page,vad[0],vad[1]))
                    vads_to_get.add(vad[0])
                    get_next = False
                prev_vad = vad
    i = 0
    vads_to_get = sorted(list(vads_to_get))
    for vad in vads_to_get:
        if min_addr <= vad and vad<= max_addr: continue
        log.debug("[+] Retrieving VAD 0x{:08X}".format(vad))
        raw_vad = _get_vad(cuckoo_api_url,args.task,args.pid,vad)
        with open('{}/0x{:08x}.dmp'.format(tmpdir,vad),'wb') as f:
            f.write(raw_vad)
    log.debug("[+] Generating IDB with new memory regions")
    if args.ida_path:
        cmd_str = """{} -Lida.log -A -S"ida_load_mem.py {}" {}""".format(args.ida_path,tmpdir,proc_dmp_file)
        p = subprocess.Popen(shlex.split(cmd_str))
        p.wait()
    shutil.copy("{}/{}".format(tmpdir,idb_path),idb_path)
    log.debug("[+] IDB available at {}".format(idb_path))
    shutil.rmtree(tmpdir)

if __name__ == "__main__":
    main()
